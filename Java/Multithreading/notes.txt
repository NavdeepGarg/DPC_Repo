https://www.youtube.com/watch?v=fd3TAYCHRfw&list=PLd3UqWTnYXOlHj_fVVjUIVHjD5uEy2kk4&index=3


Watch Durga Series and Telusko Series. 1.75x mode

too much to write 


volatile variable --> shared var and access directly from main memory.
						provides visibility and not atomicity
						
synchronized keyword provides atomicity

atomic variable provides both visibility and atomicity
https://www.youtube.com/watch?v=71dgtPrbToE



****************************************************************************************************************************************************************


MultiTasking
 •Process Based
	Typing Java Prog, Internet usage, Listenig Music all happenging at same time is process based.
	This MultiTasking is happenig at OS level
 
 •Thread Based
	This MultiTasking is happenging at Program level 
	To develop webserver and App server it comes into use.



•Sample Prog
					package thread;
					class MyThread extends Thread{
						
						@Override
						public void run() {
							for(int i =0 ; i < 5;i++) {
								System.out.println("i "+i);
							}
						}
						
						
					}
					public class ThreadDemo {
						
						public static void main(String[] args) {
							
							
							MyThread th = new MyThread();// Thread Instantiation
							
							th.start();// thread started by main thread
							
							// here after this main and child both exist in system now
							
							
						}

								

					}


•Thread Scheduler decides the thread execution order. However we cannot guarntee the exact algo for thread scheduler it varies from JVM to JVM.
 Hence thread execution order caannot be predicted laymenly.
 
•start() method :
	•It is respomnsible to regster with Thread scheduler and all other mandaotry activities.
	•Invoke run method of given Thread
	•Not advisable to override the start method.
	•Illegable Thread state exception will come if we call start method twice.

•yield() 
	•causes to pause the current executing thread to give the chance for waiting thread of same priority , if there 
	 is no waiting thread or all all waiing thread have low priority then same thread can continute its execution.
	 •The thread which is yielded when it will get the chance once again it will depends on Thread scheduler and we cant expect immediatley.
	 •public static native void yield()
	 
	 
•join()
	•If a thread want to wait untill completing some other thread, then we should go for join() method.
	For eg. if thread t1 wants to wait untill completing t2, then t1 has to call t2.join() and then immeditaley t1 will go in waiting state untill t2 completes.
	Once t2 completes , t1 can continue its execution.
	•Three Join methods available
		•join() , join(milliseconds), join(milliseconds,nanoseconds)
		
	
•sleep()
	If a thread dont want to perfomr any operation fo ra particular anount of time , then we should use sleep() method
	•2 sleep methods are available
	•public static native void sleep(milliseconds)
	•public static native void sleep(milliseconds, nanoseconds)
	
•Interuption
	•A thread can interrupt a sleeping thread or waiting thread by using , public void interrupt() method of Thread class.
	•Example
		package thread;

			class MythreadDemo extends Thread{

				public void run() {
					try {
						for(int i =0; i < 10; i++) {
							System.out.println("I am a Lazy Thread");

							Thread.sleep(2000);

						}
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						System.out.println("I got Interrupted");

					}

				}
			}


			public class ThreadInterruptDemo {
				public static void main(String[] args) {
					MythreadDemo d = new MythreadDemo();
					d.start(); // at this line system has two thread one is d and other is main thread		
					d.interrupt();//here main thread is interrupting the thread 'd'
					System.out.println("end of main thread");
				}

			}
			
	•Whenever we are calling interrupt method, if the target thread not in sleeping state/ waiting state then there is no impact of interrupt call immediately.
		•Interrupt call will be waited untill target thread enter into sleeping / waiting state. If the target thread sleeping or waiting state, 
		then immediately interrupt call will interrupt the target thread.
		•JVM handles such interrupt calls.
		•Interrupt call can go wasted if the target thread never enter into sleeping / waiting state in its life time.


	
	
	

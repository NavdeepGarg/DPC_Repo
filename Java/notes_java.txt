•Find out the different version differences in java 
from java 8 to 11

strictness order of modifiers:
	private>default>protected>public

•default is package private identifier, i.e. it scope will not be visible outside package , chahe voh subclass hi kyu na ho.

•volatile keyword solve the visibilty prob not synchrnization prob.
	•volatile modifiers variable pass on their values from their local cache to shared cache immediately.
	
•atomic variable are basically used in case of compund operations like increment / decrement.
	•These operations are actually two step processes fetch then add . sometimes in synchrnization it is possible that the incremented value is not read by other thread.
	to solve such cases atomicvariables are introduced.
	•Second approach for the above said problem isusing volatile and synchronized block together.

•Double checking is the concept in multithrading environment which mostly used in singleton application.
	Example:
	public class DclSingleton {
    private static volatile DclSingleton instance;
    public static DclSingleton getInstance() {
        if (instance == null) {
            synchronized (DclSingleton .class) {
                if (instance == null) { // double checking happening here.
                    instance = new DclSingleton();
                }
            }
        }
        return instance;
    }

    // private constructor and other methods...
}

•Java Generics with extends and super Wildcards
	•private static double sum(Collection<? extends Number> numbers) {} , in this method call 
		1)List<Integer> integers 2)List<Double> double 3)List<Number> number all canbe passed because all extends Number
	•public static void append(Collection<? super Integer> integers, int n) {} , in this method call
		1)List<Object> objects 2)List<Number> number all canbe passed because these are super class of Integer
•Java’s generic type parameters are invariant. This means for any distinct types A and B, G<A> is not a subtype or supertype of G<B>. As a real world example, List<String> is not a supertype or subtype of List<Object>. So even though String extends (i.e. is a subtype of) Object, both of the following assignments will fail to compile:
	List<String> strings = Arrays.<Object>asList("hi there");
        List<Object> objects = Arrays.<String>asList("hi there");

•Remember PECS: "Producer(Read operation) Extends, Consumer(Add operations) Super".

•Learn internal functioning of TreeSet and HashSet and HashMap
https://javahungry.blogspot.com/2013/08/how-sets-are-implemented-internally-in.html
https://javahungry.blogspot.com/2015/10/how-treeset-works-internally-in-java-interview-questions.html
https://javahungry.blogspot.com/2013/08/hashing-how-hash-map-works-in-java-or.html
https://javahungry.blogspot.com/2014/02/hashmap-vs-concurrenthashmap-java-collections-interview-question.html

•https://www.toptal.com/java/interview-questions
#####################Design Patter Notes#####################

•It is a reusable solution to commonly occuring problem within in a givn context of software design.

•Make sure your design is in such a way that it is adaptable to change

Smells are the indication that you are doing something wrong.
	•like rigidity,fragility,tight coupling ,needless repetition,too many public members(it violates encapsulation)

Program to an interface and do for implementation.It is a common theme of design pattern.

Composition has many benefits than inheritance.
	•It offer loose coupling.
	•It provide more extensibility bcoz there is least to bother about the inheritance linkage
	•There is always most time spent on code after its development, so better to think for extensibility wherever it can be  applicable.
	 This argument favors Composition over Inheritance.
	•Composition enhance polymorphism

Delegation
	•when a class delegate some task to other class to accomplish
	•It also uses the cOmposition principle.
	•equals() and hashCode() is the classic example.
	 In order to compare two objects for equality we ask the class itself to do the comparison instead of client class doing that check.
	
Dependency Inversion Principle(DIP)


	•High-level modules(Jo depend kar rhe hai doosri class par) should not depend on low-level modules(Jis class par depend kar rhe hai). Both should depend on the abstraction.
	•Abstractions should not depend on details. Details should depend on abstractions.

	•encourage the thinking in making of abstraction/interfaces.
	•think first of abstraction than concrete class.
	•if you are overriding the implemented method in superclass, it means you have not done the abstraction properly, rethink and change the design
	coz it will end up in high coupling.
	•No 2 concrete class shall be directly dependant on each other.
	•Any 2 concrete class should depend on each other via an interface
	•what inversion is happening is the , not getting implementation directly from the class but via interfcae implementation.
	
	e.g.
	class Paytm{
	 PaytmPaymentProcessor paymentProcessor;
	}
	
	interface PaytmPaymentProcessor{
	//relvant methods.
	}
	// following are the 2 currentl available implementtion of PaytmPaymentProcessor
	RazorPay implements PaytmPaymentProcessor{
	}
	JustPay implements PaytmPaymentProcessor{
	}

	
Dependency Injection:
	•It goes hand in hand with DIP
	•if you want to use DI, following 4 roles will be required
		•the service you want to use
		•the client uses the service
		•an interface that is used by the client(composition rule) and implemented by a service
		•injector which creates a service instance and inject it to the client.
		
UML is the documentation technique in a visual way that describe design.

Creational Pattern
 •Abstract Factory Pattern(with static creator)
	
	
 •Singleton
	•Most simplest • ensure class has only one instance and provide global point of access to it
	•example printer,file system etc.
	•In its implementation , using 'synchronized' keyword inthe getinstance() method will create lot of overhead and also synchronization is required only for 
	the time when the object is going to be created for the very first time.Thus it creates performance issue.
	•To tackle the performance issue double check locking is applied, where synchronized block is used.
					
					enum Singleton
				{
					INSTANCE;
					// instance vars, constructor
				 
					private final Connection connection;
					 
					Singleton()
					{
						// Initialize the connection
						connection = DB.getConnection();
					}
				 
					// Static getter
					public static Singleton getInstance()
					{
						return INSTANCE;
					}
				 
					public Connection getConnection()
					{
						return connection;
					}
				}
	
	
ISOLATION LEVELS:
TRANSACTION_READ_UNCOMMITTED- 1
TRANSACTION_READ_COMMITTED- 2 (Dirty read solved)
TRANSACTION_REPEATBLAE_READ- 4 (Dirty read, non-repeatable are solved , Phantom not possible ) --DEFAULT IMPLEMENTATION
TRANSACTION_SERIALIZABLE- 8 (Not recommended) -Whole Table Locked--Dirty read, non-repeatable,uncommitted read all problem solved.

getTransactionIsolation()
setTransactionIsolation(int level)


DriverManager :> con = DM.getConnection(jdbc url, user,pwd) : always a new connection is created.
DataSource:> con=ds.getConnection() : from connection pool.

•Jasypt 1.9.3 is a java library which allows the developer to add basic encryption capabilities to his/her projects with minimum effort, and without the need of having deep knowledge on how cryptography works.
•Quartz 2.2 is an open source job scheduling library that can be integrated within virtually any Java application
•log4J a logging library for Java


•Enum
   •are the classes that have a fixed set of constants or variables that so not itend to chnage. The enumerarion in 	Java is achieved using keyword enum. The Java enum constants are static and final implicitly.
   •Enum week example, Enum job example(Contract , Temporary, Permanent)
   •Class constants can be overridden and it support creation of objects WHILE Enums cconstants cant be overrideen and it doesnt support creation of objects.
   •enum cannot extend ither classes but cqan implements interface
   •

•Deep Cloning and Shallow Cloning
	•clone method in object class is doing shallow cloning, if we want deep cloning we need to override the method.
	•clonign literal meaning is exact copy
	Shallow Cloning
		•The process of creating exactly duplicate copy of original object,  if original object contains any reference variables then duplicate copies wont be created for contained object, just duplicate ref var will be created.
	
	Deep Cloning:
		•The process of creating completely independeny duplicate object is called depp cloning
		•
	Examples attached

•constraints will help in knowing the data type required.
• the max value of the constraints helps in deciding the approach of Time complexity of the algorithm.
	e.g. 1<N<10^18    then our TC should always be O(logn) to satisfy the constraints

•IBH Method is Recursive code writing term.
	•Induction Basecase and Hypothesis
	•Hypo - is just the labeling the name and input for your desired function
	•Induction is the most important step , as it tranfer the flow from one state to next "reduced" state.. It is important to write it well in order to get correct result.
		It also includes the followup statement i.e. what shall happen when function call returns.
	•Base case is the smallest valid input identification.

•Recursion tree method is again similar to IBH only with different mind approach.	
	•Here in genral no. of branches from a given node is actually nothing but no. of choices.
	•Once we can imagine a rec tree , its corresponding coding will be cakewalk.
	
•In DP , using recursive approach , I personally have following observation
	•Use Top Down approach while writing the recurisve code. i.e. dont start from 0th index start from nth index
	•While memoizing(Top-Down) use dimension as +1 concept. 
	•Use position instead of index.


•WRiTE FOR BIN SEARCH, DFS, BFS,  cumulative sum

•Scope of Improvement 
	•Any repetitive work.
	•Any repetetive work.

•Sliding  Window
	•Variable window size , Fixed Window size
	

•Graph
	
	Implementation
	1)ArrayList<Edge>[] graph = new ArrayList<Edge>[7] and Edge {int src, int nbr, int weight};
	2)Either DFS or BFS a vertex is marked visited on its discovery itself. Keeping the track of visited array is required in order to avoid the revisiting the same vertex and avoid enter into any cycle
	3)For checking all posible path , visited[src]=false before returing the funciton call, this is required to keep the src vertex open to be discovered if it comes in any other path which can reach till destinatoin.


